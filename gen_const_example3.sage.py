

# This file was *autogenerated* from the file gen_const_example3.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_256 = Integer(256); _sage_const_255 = Integer(255); _sage_const_7 = Integer(7); _sage_const_0xba41f30a2231820b3fa2957bae0b9fed1801dff14e9cded971efdb63aeb369d5 = Integer(0xba41f30a2231820b3fa2957bae0b9fed1801dff14e9cded971efdb63aeb369d5); _sage_const_0 = Integer(0); _sage_const_3 = Integer(3); _sage_const_4 = Integer(4); _sage_const_250 = Integer(250); _sage_const_16 = Integer(16)
i = _sage_const_1 
while i:
    p = random_prime(_sage_const_2 **_sage_const_256 , lbound=_sage_const_2 **_sage_const_255 )
    if kronecker(-_sage_const_7 , p) == -_sage_const_1 :
        continue
    p=_sage_const_0xba41f30a2231820b3fa2957bae0b9fed1801dff14e9cded971efdb63aeb369d5 
    F = GF(p)
    E = EllipticCurve(F, [_sage_const_0 , -_sage_const_3 /_sage_const_4 , _sage_const_0 , -_sage_const_2 , -_sage_const_1 ])

    n = E.order()
    fac = n.factor()

    # on cherche un facteur premier ~256 bits
    for q,e in fac:
        if q.nbits() > _sage_const_250  and q.is_prime():
            r = q
            h = n // r
            if h <= _sage_const_16   :
                print("GOOD CURVE FOUND")
                print("p =", hex(p))
                print("r =", hex(r))
                print("h =", h)
                i = _sage_const_0 


print("n =", hex(n))
print(fac)

P = E.random_point()
print("n//P.order() ", hex(n//P.order()))
print("P =", hex(P[_sage_const_0 ]), hex(P[_sage_const_1 ]), hex(P[_sage_const_2 ]))

r = fac[_sage_const_1 ][_sage_const_0 ]
R = Integers(r)
s = R(-_sage_const_7 ).sqrt(all=True, extend=False)[_sage_const_0 ]  # racine de -7 mod p^e
inv2 = R(_sage_const_2 )**-_sage_const_1                          # inverse de 2 modulo p^e
x = (_sage_const_1  + s) * inv2
print("lambda = ", hex(x))

R = Integers(p)
t = R(-_sage_const_7 ).sqrt(all=True, extend=False)[_sage_const_0 ]  # racine de -7 mod p^e
inv2 = R(_sage_const_2 )**-_sage_const_1                          # inverse de 2 modulo p^e
y = (_sage_const_1  + t) * inv2
print("beta = ", hex(y))

