\documentclass[10pt]{beamer}

% --- Configuration du Thème ---
\usetheme{Madrid} 
\usecolortheme{whale} 

% --- Packages ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{listings} 
\usepackage{xcolor}

% --- Configuration Code C ---
\lstset{
    language=C,
    basicstyle=\ttfamily\scriptsize,
    keywordstyle=\color{blue},
    commentstyle=\color{gray},
    stringstyle=\color{red},
    breaklines=true,
    frame=single,
    showstringspaces=false
}

% --- Données ---
\title[Méthode GLV]{Analyse Exhaustive et Implémentation de la Méthode GLV sur Courbes Elliptiques}
\subtitle{Rapport Projet C} 

\author[A. Roullet, B. Saudubray]{
    Alexandre \textsc{Roullet} \and Bassem \textsc{Saudubray} \\[0.5cm]
    {\small {Supervision : Sorina \textsc{Ionica}}}
}

\institute{M2AA}
\date{13 février 2026}

% --- Début de la présentation ---
\begin{document}

% ------------------------------------------------
% Slide de Titre
% ------------------------------------------------
\begin{frame}
    \titlepage
\end{frame}

% ------------------------------------------------
% Plan
% ------------------------------------------------
\begin{frame}{Plan de la présentation}
    \tableofcontents
\end{frame}

% ================================================
% SECTION 1 : CONTEXTE
% ================================================
\section{Introduction et Contexte}

\begin{frame}{Contexte : La Cryptographie Elliptique (ECC)}
    \begin{block}{Pourquoi l'ECC ?}
        \begin{itemize}
            \item Sécurité équivalente à RSA avec des clés beaucoup plus petites.
            \item \textbf{256 bits} ECC $\approx$ \textbf{3072 bits} RSA.
            \item Utilisé partout : Blockchain, TLS 1.3, IoT.
        \end{itemize}
    \end{block}

    \begin{alertblock}{La Problématique}
        L'opération centrale est la \textbf{Multiplication Scalaire} :
        $$ Q = k \cdot P = \underbrace{P + P + \dots + P}_{k \text{ fois}} $$
        \begin{itemize}
            \item Pour $k \approx 2^{256}$, l'approche naïve est impossible.
            \item Méthode classique (Double-and-Add) : $\approx 384$ opérations de groupe.
        \end{itemize}
    \end{alertblock}
\end{frame}

\begin{frame}{La Solution GLV (Gallant-Lambert-Vanstone)}
    \begin{block}{Idée Clé (2001)}
        Ne pas considérer la courbe comme un groupe quelconque, mais exploiter ses propriétés géométriques (Endomorphismes).
    \end{block}

    \textbf{Principe :} Décomposer le grand scalaire $k$ en deux "mini-scalaires" $k_1, k_2$ de taille moitié ($\approx 128$ bits).
    
    $$ k \cdot P = k_1 P + k_2 \phi(P) $$

    \begin{itemize}
        \item $\phi(P)$ est calculable très rapidement.
        \item Permet de paralléliser les calculs (Multiplication Simultanée).
        \item \textbf{Objectif :} Réduire de 50\% le nombre de doublements.
    \end{itemize}
\end{frame}

% ================================================
% SECTION 2 : FONDEMENTS MATHÉMATIQUES
% ================================================
\section{Fondements Mathématiques}

\begin{frame}{Courbes Elliptiques et Coordonnées}
    Courbe de Weierstrass sur $\mathbb{F}_p$ ($p > 3$) :
    $$ y^2 = x^3 + ax + b \pmod p $$

    \begin{columns}
        \column{0.48\textwidth}
        \begin{block}{Coordonnées Affines $(x,y)$}
            \begin{itemize}
                \item Addition nécessite une inversion modulaire $I$.
                \item $I$ est très coûteuse ($1I \approx 80M$).
            \end{itemize}
        \end{block}

        \column{0.48\textwidth}
        \begin{exampleblock}{Coordonnées Jacobiennes $(X:Y:Z)$}
            \begin{itemize}
                \item $x = X/Z^2, y = Y/Z^3$.
                \item \textbf{Aucune inversion} dans la boucle.
                \item Coût du doublement réduit de $7M$ à $4M$.
            \end{itemize}
        \end{exampleblock}
    \end{columns}
\end{frame}

% ------------------------------------------------
% SLIDE 1 : DÉFINITION THÉORIQUE (Allégée)
% ------------------------------------------------
\begin{frame}{Les Endomorphismes GLV ($\phi$)}
    \begin{block}{Définition}
        Un endomorphisme est une application rationnelle $\phi : E \to E$ qui agit comme un scalaire $\lambda$ sur un sous-groupe :
        $$ \phi(P) = \lambda P \quad \text{où } \lambda^2 - T\lambda + N \equiv 0 \pmod n $$
    \end{block}

    \vspace{0.5cm}
    Cette propriété permet de remplacer le calcul de $2^{128} P$ par une évaluation de $\phi(P)$, beaucoup plus rapide.

    \vspace{0.5cm}
    \textbf{Nous avons étudié la classification proposée par Gallant, Lambert et Vanstone :}
    \begin{itemize}
        \item Endomorphismes simples (multiplication par une constante).
        \item Endomorphismes rationnels (fractions).
    \end{itemize}
\end{frame}

% ------------------------------------------------
% SLIDE 2 : CAS SIMPLES (Type 1 & 2)
% ------------------------------------------------
\begin{frame}{Classification : Les Cas Simples (Implémentés)}
    Ces courbes possèdent un endomorphisme de degré 1 (très efficace).

    \begin{block}{Type 1 : Courbes avec $j=0$}
        Equation : $E: y^2 = x^3 + b \pmod p$
        \begin{itemize}
            \item \textbf{Action :} $\phi(x,y) = (\beta x, y)$ avec $\beta^3 \equiv 1 \pmod p$.
            \item \textbf{Complexité :} 1 multiplication modulaire.
        \end{itemize}
    \end{block}

    \begin{block}{Type 2 : Courbes avec $j=1728$}
        Equation : $E: y^2 = x^3 + ax \pmod p$
        \begin{itemize}
            \item \textbf{Action :} $\phi(x,y) = (-x, i y)$ avec $i^2 \equiv -1 \pmod p$.
            \item \textbf{Complexité :} 1 multiplication modulaire.
        \end{itemize}
    \end{block}
\end{frame}

% ------------------------------------------------
% SLIDE 3 : CAS COMPLEXES (Type 3 & 4)
% ------------------------------------------------
\begin{frame}{Classification : Les Cas Complexes}
    Ici, l'endomorphisme est une fraction rationnelle.

    \begin{alertblock}{Type 3 : Courbes avec $D=7$ (Implémenté)}
        Défini sur $\mathbb{Q}(\sqrt{-7})$.
        $$ \phi(x,y) = \left(\frac{x^2 - \xi}{\xi^2(x-a)}, \dots\right) $$
        \textbf{Défi :} L'ordre $N$ n'est pas premier ($N=4r$). Nécessite une gestion fine du sous-groupe et un isomorphisme.
    \end{alertblock}

    \begin{exampleblock}{Type 4 : Courbes avec $D=8$ (Non Implémenté)}
        Equation : $y^2 = 4x^3 - 30x - 28 \pmod p$.
        Endomorphisme défini sur $\mathbb{Q}(\sqrt{-2})$ :
        $$ \phi(x,y) = \left( - \frac{2x^2 + 4x + 9}{4(x + 2)} , \frac{-(2x^2 + 8x - 1)y}{4\sqrt{-2}(x + 2)^2} \right) $$
        \textit{Non traité pour se concentrer sur la résolution des problèmes du Type 3.}
    \end{exampleblock}
\end{frame}

% ------------------------------------------------
% SLIDE 4 : FOCUS TYPE 3
% ------------------------------------------------
\begin{frame}{Focus : La Complexité du Type 3}
    \textit{Une difficulté mathématique majeure rencontrée durant le projet.}

    Pour les courbes de Type 3 ($D=7$), l'ordre $N$ n'est pas premier :
    $$ N = h \cdot r \quad (\text{avec } h=4) $$
    
    \begin{alertblock}{Conséquence critique}
        GLV ne fonctionne bien que sur le sous-groupe d'ordre premier $r$.
        \begin{itemize}
            \item Il faut travailler modulo $r$.
            \item Le point $P$ doit être dans le sous-groupe (annuler le cofacteur).
        \end{itemize}
    \end{alertblock}
\end{frame}

% ================================================
% SECTION 3 : ALGORITHMES GLV
% ================================================
\section{Algorithmes de Décomposition}

\begin{frame}{Le Problème de Décomposition}
    On cherche $k_1, k_2$ petits ($\approx \sqrt{n}$) tels que :
    $$ k \equiv k_1 + k_2\lambda \pmod n $$

    C'est un problème de \textbf{Réseau Euclidien} (Lattice).
    On cherche le vecteur du réseau $\mathcal{L} = \{ (u,v) \in \mathbb{Z}^2 \mid u + v\lambda \equiv 0 \pmod n \}$,  le plus proche de $(k, 0)$.

    \vspace{0.5cm}
    \textbf{Deux étapes clés :}
    \begin{enumerate}
        \item Trouver une base courte du réseau (Pré-calcul).
        \item Trouver les coefficients $k_1, k_2$ (Temps réel).
    \end{enumerate}
\end{frame}

\begin{frame}{Intuition Géométrique de la Décomposition}
    \begin{itemize}
        \item Le vecteur $(k, 0)$ est très loin de l'origine.
        \item Le réseau $\mathcal{L}$ est engendré par $\{(n,0), (\lambda, 1)\}$.
        \item On cherche un vecteur $v \in \mathcal{L}$ très proche de $(k,0)$.
    \end{itemize}

    \begin{block}{Le "Vecteur Erreur"}
        La différence $u = (k,0) - v$ nous donne le couple $(k_1, k_2)$.
        \begin{itemize}
            \item Comme $v$ est proche de $(k,0)$, la différence est petite.
            \item C'est ce qui garantit que $k_1$ et $k_2$ font la moitié de la taille de $k$.
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}{Étape 1 : Génération de la Base (Euclide Étendu)}
    On utilise l'algorithme d'Euclide Étendu (EEA) sur $n$ et $\lambda$.
    
    \begin{itemize}
        \item On génère une suite de restes $r_i$.
        \item On s'arrête quand $r_i < \sqrt{n}$.
    \end{itemize}

    \begin{block}{Résultat}
        On obtient deux vecteurs courts linéairement indépendants :
        $$ v_1 = (r_m, -t_m) \quad \text{et} \quad v_2 = (r_{m-1}, -t_{m-1}) $$
    \end{block}
    \textit{Cette étape est faite une seule fois à l'initialisation de la courbe.}
\end{frame}

\begin{frame}{Étape 2 : Décomposition de Babai (Rounding)}
    Pour tout scalaire $k$, on résout le système approché :
    $$ (k,0) \approx c_1 v_1 + c_2 v_2 $$
    
    \textbf{Algorithme (O(1)) :}
    1. Calcul flottant des coefficients $c_1, c_2$ (Cramer).
    2. Arrondi à l'entier le plus proche : $b_i = \lfloor c_i \rceil$.
    3. Calcul du vecteur erreur (qui est notre solution) :
    $$ (k_1, k_2) = (k,0) - b_1 v_1 - b_2 v_2 $$
    
    \begin{exampleblock}{Garantie}
        Les théorèmes bornent $|k_1|, |k_2| < \epsilon \sqrt{n}$.
    \end{exampleblock}
\end{frame}

\begin{frame}{L'Astuce de Shamir (Multi-exponentiation)}
    Une fois $k$ décomposé, comment calculer $k_1P + k_2\phi(P)$ vite ?
    
    \begin{columns}
        \column{0.45\textwidth}
        \begin{block}{Approche Naïve}
            \begin{itemize}
            \item 1. Calculer $A = k_1 P$
            \item 2. Calculer $B = k_2 \phi(P)$
            \item 3. Faire $A + B$
            \item \textbf{Coût : $\approx 2 \times$ (Doublages)}
            \end{itemize}
        \end{block}

        \column{0.45\textwidth}
        \begin{alertblock}{Approche Shamir}
            On parcourt les bits de $k_1$ et $k_2$ \textbf{en même temps}.
            \begin{itemize}
                \item Si $k_1=1, k_2=0 \to$ Add $P$
                \item Si $k_1=0, k_2=1 \to$ Add $\phi P$
                \item Si $k_1=1, k_2=1 \to$ Add $P+\phi P$
            \end{itemize}
            \textbf{Coût : $\approx 1 \times$ (Doublages)}
        \end{alertblock}
    \end{columns}
\end{frame}

% ================================================
% SECTION 4 : IMPLÉMENTATION
% ================================================
\section{Architecture et Optimisations}

\begin{frame}{Architecture Modulaire (C / GMP)}
    Organisation en couches pour séparer la logique mathématique de l'arithmétique bas niveau.
    
    \begin{itemize}
        \item \textbf{Haut niveau :} \texttt{main.c}, \texttt{glv\_acceleration.c} (Benchmarks).
        \item \textbf{Logique GLV :} \texttt{glv\_decompose.c}, \texttt{short\_vectors.c}.
        \item \textbf{Moteur :} \texttt{double\_scalar\_multiplication.c}.
        \item \textbf{Bas niveau :} \texttt{EC\_add\_proj.c} (Optimisé GMP).
    \end{itemize}
    
    \textit{Utilisation de SageMath en amont pour générer les constantes valides.}
\end{frame}

\begin{frame}[fragile]{Défis Techniques : Gestion de la Mémoire (GMP)}
    L'utilisation de la librairie GMP (GNU Multi-Precision) impose une rigueur stricte.
    
    \begin{itemize}
        \item \textbf{Allocation dynamique :} Chaque \texttt{mpz\_t} alloue de la mémoire sur le tas.
        \item \textbf{Risque :} Fuites (Memory Leaks) catastrophiques sur 10 000 itérations.
    \end{itemize}

\begin{lstlisting}
// Exemple de bonne pratique appliquee dans le projet
void clean_function(GLVCurve *curve) {
    mpz_clears(curve->n, curve->lambda, curve->beta, NULL);
    ec_point_proj_clear(&curve->P);
    ec_point_proj_clear(&curve->phiP);
    // Chaque init doit avoir son clear correspondant
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{Optimisation : Fenêtrage (Interleaving w-ary)}
    Au lieu de traiter bit par bit, on traite par fenêtre de taille $w$.

\begin{lstlisting}
// Extrait simplifie de la boucle principale (w=2)
for (i = len - 1; i >= 0; i--) {
    // 1. Doublements (w fois)
    ec_point_double_proj(...); 
    ec_point_double_proj(...); 

    // 2. Addition avec la table pre-calculee
    idx = (k1_bits << w) | k2_bits;
    ec_point_add_proj(R, &PrecomputedTable[idx], ...);
}
\end{lstlisting}

    \textbf{Compromis :} $w=2$ est optimal. Au-delà ($w=4$), le temps de pré-calcul de la table devient trop lourd.
\end{frame}

% ================================================
% DÉMO
% ================================================
\section{Démonstration}

\begin{frame}
    \begin{center}
        \Huge Démonstration Informatique
        
        \vspace{1cm}
        \normalsize
        \begin{enumerate}
            \item Compilation du projet.
            \item Exécution des tests unitaires (Type 1, 2 et 3).
            \item Benchmark : Classique vs GLV.
        \end{enumerate}
    \end{center}
\end{frame}

% ================================================
% SECTION 5 : RÉSULTATS
% ================================================
\section{Analyse des Résultats}

\begin{frame}{Méthodologie de Validation}
    Avant de mesurer la performance, nous avons validé l'exactitude mathématique.

    \begin{enumerate}
        \item \textbf{Génération des constantes :} Script SageMath pour trouver $\lambda$, $\beta$ et les vecteurs de base.
        \item \textbf{Tests Unitaires en C :}
        \begin{itemize}
            \item Vérification que le point est sur la courbe ($Y^2 = X^3 + aX + b$).
            \item Vérification de l'endomorphisme : $\phi(P) == \lambda P$.
            \item Vérification GLV : $kP == k_1P + k_2\phi(P)$.
        \end{itemize}
        \item \textbf{Validation Croisée :}
        \begin{itemize}
            \item Pour chaque test, on calcule $Q_1 = kP$ (Méthode Classique).
            \item On calcule $Q_2 = kP$ (Méthode GLV).
            \item \textbf{Succès si :} $Q_1 == Q_2$
        \end{itemize}
    \end{enumerate}
\end{frame}

\begin{frame}{Protocole de Test}
    \begin{itemize}
        \item \textbf{Échantillon :} 1000 multiplications scalaires (256 bits).
        \item \textbf{Comparaison :} Méthode GLV ($w=2$) vs Méthode GMP Classique Projective.
    \end{itemize}

    \begin{table}
        \centering
        \begin{tabular}{|c|c|c|c|}
            \hline
            \textbf{Type Courbe} & \textbf{Classique (s)} & \textbf{GLV (s)} & \textbf{Gain (Speedup)} \\
            \hline
            Type 1 ($j=0$) & 0.485 & 0.275 & \textbf{1.76 x} \\
            Type 2 ($j=1728$) & 0.496 & 0.282 & \textbf{1.76 x} \\
            Type 3 ($D=7$) & 0.525 & 0.297 & \textbf{1.77 x} \\
            \hline
        \end{tabular}
        \caption{Moyenne sur 1000 itérations avec $w=2$}
    \end{table}
\end{frame}

\begin{frame}{Analyse de la Performance}
    \begin{block}{Résultat Principal}
        Nous atteignons une accélération de \textbf{76\%}.
        $$ \text{Temps GLV} \approx 0.57 \times \text{Temps Classique} $$
    \end{block}

    \textbf{Pourquoi pas 2.0x (100\%) ?}
    \begin{itemize}
        \item Coûts fixes : Conversion Affine $\to$ Projectif.
        \item Overhead de Babai (arithmétique grands nombres).
        \item Gestion mémoire dynamique (malloc/free) de GMP.
    \end{itemize}
    
    \textit{Performance supérieure aux prédictions originales (approx. 50\%).}
\end{frame}

% ================================================
% CONCLUSION
% ================================================
\section{Conclusion}

\begin{frame}{Conclusion}
    \begin{enumerate}
        \item \textbf{Implémentation Réussie :} Méthode GLV fonctionnelle sur des courbes simples et rationnelles (Type 3).
        \item \textbf{Optimisation Validée :} L'association GLV + Coordonnées Jacobiennes + Fenêtrage ($w=2$) offre le meilleur rendement.
        \item \textbf{Robustesse :} Gestion mémoire sans fuite et rigueur mathématique (cofacteur géré).
    \end{enumerate}

    \vspace{0.5cm}
    \begin{block}{Perspectives}
        Portage sur carte à puce (sans allocation dynamique) pour l'embarqué.
    \end{block}
\end{frame}

\begin{frame}
    \begin{center}
        \Huge Merci de votre attention.
        
        \vspace{1cm}
        \Large Avez-vous des questions ?
    \end{center}
\end{frame}

\end{document}