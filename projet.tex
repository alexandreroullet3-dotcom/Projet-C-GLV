\documentclass[12pt, a4paper]{article}

% --- 1. PARAMÈTRES DE MISE EN PAGE (Pour atteindre ~10-12 pages) ---
\usepackage{geometry}
\geometry{hmargin=3cm, vmargin=3cm} % Marges larges
\usepackage{setspace}
\onehalfspacing % Interligne 1.5 (aère le texte)

% Forcer un saut de page avant chaque nouvelle section
\let\stdsection\section
\renewcommand\section{\newpage\stdsection}

% --- 2. PAQUETS ESSENTIELS ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{lmodern} % Police vectorielle propre
\usepackage{amsmath, amssymb, amsfonts} % Maths
\usepackage{url}
\usepackage{hyperref}
\hypersetup{colorlinks=true, linkcolor=black, urlcolor=blue!60!black}
\usepackage{booktabs} % Pour les beaux tableaux

% --- 3. CONFIGURATION DU CODE C ---
\usepackage{listings}
\usepackage{xcolor}

\lstset{
    language=C,
    basicstyle=\ttfamily\small, % Code légèrement plus petit pour rester propre
    keywordstyle=\color{blue!60!black}\bfseries,
    commentstyle=\color{green!40!black}\itshape,
    stringstyle=\color{orange!70!black},
    numbers=left,
    numbersep=8pt,
    numberstyle=\tiny\color{gray},
    breaklines=true,
    frame=lines, % Lignes simples en haut et bas
    backgroundcolor=\color{gray!5}, % Fond gris très léger
    showstringspaces=false,
    inputencoding=utf8,
    extendedchars=true,
    literate={á}{{\'a}}1 {ã}{{\~a}}1 {é}{{\'e}}1 {è}{{\`e}}1 {ê}{{\^e}}1 {ë}{{\"e}}1,
    captionpos=b
}

% --- 4. INFOS DOCUMENT ---
\title{
    \vspace{-1cm}
    \rule{\linewidth}{1pt} \\[0.5cm]
    \textbf{\LARGE Optimisation de la Multiplication Scalaire sur les Courbes Elliptiques} \\[0.3cm]
    \large Une Analyse Exhaustive de la Méthode Gallant-Lambert-Vanstone (GLV)
    \vspace{0.5cm} \\
    \rule{\linewidth}{1pt}
}
\author{Rapport Technique}
\date{\today}

\begin{document}

\maketitle
\thispagestyle{empty} % Pas de numéro sur la page de titre

\vspace{2cm}
\begin{abstract}
\noindent Ce rapport propose une analyse approfondie de la méthode GLV, introduite par Gallant, Lambert et Vanstone. Nous explorerons les fondements théoriques des endomorphismes sur les courbes elliptiques, détaillerons les algorithmes de décomposition scalaire utilisant la réduction de réseau, et quantifierons les gains d'efficacité. De plus, nous fournirons une structure détaillée pour une implémentation en langage C utilisant la bibliothèque GMP.
\end{abstract}

\newpage
\tableofcontents
\newpage

% ===================================================================
\section{Introduction}

La cryptographie sur courbes elliptiques (ECC) s'est imposée comme la pierre angulaire de la sécurité de l'information moderne, offrant des niveaux de sécurité équivalents à ceux des systèmes traditionnels tels que RSA ou DSA, mais avec des tailles de clés considérablement réduites. Par exemple, une clé de courbe elliptique de 256 bits fournit une résistance cryptographique comparable à une clé RSA de 3072 bits. Cette efficacité spatiale se traduit directement par des économies de bande passante et de stockage, rendant l'ECC indispensable pour les environnements contraints tels que les cartes à puce, les dispositifs IoT et les protocoles de communication mobile.

Au c\oe ur de tous les protocoles basés sur l'ECC, qu'il s'agisse de l'échange de clés (ECDH), de la signature numérique (ECDSA) ou des preuves à divulgation nulle de connaissance, réside une opération fondamentale : la multiplication scalaire. La multiplication scalaire, notée $Q=kP$, consiste à calculer le multiple d'un point $P$ sur une courbe elliptique $E$ par un entier scalaire $k$. Cette opération est l'analogue additif de l'exponentiation modulaire dans les groupes multiplicatifs. Étant l'opération dominante en termes de coût de calcul, la performance globale de tout cryptosystème ECC est intrinsèquement liée à l'efficacité de l'algorithme de multiplication scalaire utilisé.

Les approches génériques, telles que l'algorithme de doublement-et-addition (double-and-add) ou ses variantes fenêtrées (w-NAF), traitent le groupe des points $E(\mathbb{F}_q)$ comme un groupe abélien générique. Ces méthodes présentent une complexité logarithmique en fonction de la taille du scalaire $k$, nécessitant environ $\log_2 k$ doublements de points et un nombre variable d'additions.

En 2001, Robert Gallant, Robert Lambert et Scott Vanstone ont introduit une méthode révolutionnaire, désormais connue sous le nom de méthode GLV. Cette technique marque une rupture paradigmatique en exploitant des structures algébriques spécifiques disponibles sur certaines classes de courbes elliptiques : les endomorphismes efficacement calculables. En utilisant ces endomorphismes, la méthode GLV permet de décomposer le scalaire $k$ en une combinaison linéaire de scalaires plus petits, transformant ainsi une unique multiplication scalaire de grande taille en une multi-multiplication simultanée de vecteurs plus courts.

Ce rapport propose une analyse approfondie et rigoureuse de la méthode GLV. Nous explorerons les fondements théoriques des endomorphismes sur les courbes elliptiques, détaillerons les algorithmes de décomposition scalaire utilisant la réduction de réseau (notamment l'algorithme d'Euclide étendu partiel), et quantifierons les gains d'efficacité théoriques et empiriques. De plus, nous fournirons une structure détaillée pour une implémentation future en langage C utilisant la bibliothèque GMP (GNU Multiple Precision), avant d'examiner les extensions modernes de la méthode, telles que la méthode Galbraith-Lin-Scott (GLS).

% ===================================================================
\section{Fondements Théoriques}

Pour appréhender la mécanique de la méthode GLV, il est impératif de comprendre la structure de l'anneau des endomorphismes d'une courbe elliptique définie sur un corps fini. Contrairement aux courbes génériques dont l'anneau d'endomorphismes est trivial (isomorphe à $\mathbb{Z}$), les courbes exploitées par GLV possèdent une structure plus riche connue sous le nom de Multiplication Complexe (CM).

\subsection{L'Anneau des Endomorphismes}

Soit $E$ une courbe elliptique définie sur un corps fini $\mathbb{F}_q$. Un endomorphisme $\phi$ est une application rationnelle $\phi: E \to E$ qui respecte la structure de groupe de la courbe. Formellement, $\phi$ doit satisfaire deux conditions :
\begin{enumerate}
    \item $\phi(\mathcal{O}) = \mathcal{O}$, où $\mathcal{O}$ est le point à l'infini (l'élément neutre du groupe).
    \item $\phi(P+Q) = \phi(P) + \phi(Q)$ pour tous points $P, Q \in E(\bar{\mathbb{F}}_q)$.
\end{enumerate}

L'ensemble de ces endomorphismes forme un anneau, noté $\text{End}(E)$. Pour toute courbe elliptique, cet anneau contient au minimum les endomorphismes de multiplication par un entier $m$, notés $[m]$. Cependant, pour certaines courbes spécifiques, l'anneau $\text{End}(E)$ est strictement plus grand que $\mathbb{Z}$. Dans le cas des courbes elliptiques ordinaires, $\text{End}(E)$ est isomorphe à un ordre dans un corps quadratique imaginaire $\mathbb{Q}(\sqrt{-D})$. On dit alors que la courbe possède une Multiplication Complexe.

La méthode GLV cible spécifiquement les courbes où cet endomorphisme supplémentaire $\phi$ est non seulement défini sur le corps de base $\mathbb{F}_q$, mais est également très efficace à évaluer numériquement — idéalement beaucoup plus rapide qu'une opération de doublement de point.

\subsection{L'Action sur les Sous-groupes}

Considérons un point $P \in E(\mathbb{F}_q)$ d'ordre premier $n$ élevé. Si l'endomorphisme $\phi$ est défini sur $\mathbb{F}_q$, il transforme les points rationnels en points rationnels. De plus, en tant qu'homomorphisme de groupe, il doit mapper le sous-groupe cyclique $\langle P \rangle$ vers lui-même. L'action de $\phi$ sur tout point $Q \in \langle P \rangle$ correspond à une multiplication scalaire par un entier $\lambda \in [1, n-1]$ :
$$ \phi(P) = [\lambda]P $$

Ici, $\lambda$ est une valeur propre de l'endomorphisme. Algébriquement, $\lambda$ est une racine du polynôme caractéristique de l'endomorphisme $\phi$ modulo $n$. Si le polynôme caractéristique est $X^2 - TX + N = 0$, alors $\lambda$ satisfait la congruence :
$$ \lambda^2 - T\lambda + N \equiv 0 \pmod n $$

L'efficacité de la méthode GLV repose sur une prémisse fondamentale : le coût de calcul de l'application $\phi(P)$ doit être négligeable par rapport au coût de la multiplication scalaire explicite $[\lambda]P$.

\subsection{Exemples Canoniques de Courbes GLV}

\subsubsection*{Exemple A : Courbes avec j-invariant 1728}
Considérons la famille de courbes $E_1$ définies sur un corps premier $\mathbb{F}_p$ où $p \equiv 1 \pmod 4$ :
$$ y^2 = x^3 + ax $$
Cette courbe possède un endomorphisme $\phi$ défini par $\phi(x,y) = (-x, \alpha y)$ où $\alpha^2 \equiv -1 \pmod p$.
Le polynôme caractéristique est $X^2+1=0$. Par conséquent, la valeur propre $\lambda$ satisfait $\lambda^2 \equiv -1 \pmod n$. L'application nécessite uniquement une multiplication modulaire pour la coordonnée $y$.

\subsubsection*{Exemple B : Courbes avec j-invariant 0 (secp256k1)}
C'est le cas le plus célèbre, utilisé par Bitcoin. Considérons la courbe $E_2$ définie sur $\mathbb{F}_p$ où $p \equiv 1 \pmod 3$ :
$$ y^2 = x^3 + b $$
Cette courbe admet un endomorphisme $\phi$ défini par $\phi(x,y) = (\beta x, y)$ où $\beta^3 \equiv 1 \pmod p$.
Le polynôme caractéristique est $X^2+X+1=0$. La valeur propre $\lambda$ satisfait donc $\lambda^2 + \lambda + 1 \equiv 0 \pmod n$. L'évaluation coûte une seule multiplication modulaire sur la coordonnée $x$.

% ===================================================================
\section{La Méthode GLV : Fonctionnement}

L'innovation centrale de la méthode GLV réside dans la réécriture de la multiplication scalaire $kP$. Au lieu de calculer directement ce produit, on cherche à exprimer $k$ sous la forme d'une combinaison linéaire de scalaires plus petits, exploitant la relation $\phi(P) = \lambda P$.

\subsection{Le Problème de la Décomposition}

Pour un scalaire $k \in [1, n-1]$, l'objectif est de trouver deux entiers $k_1$ et $k_2$ tels que :
$$ k \equiv k_1 + k_2\lambda \pmod n $$
avec la contrainte cruciale que $k_1, k_2 \approx \sqrt{n}$. Si cette décomposition est trouvée, nous pouvons utiliser l'endomorphisme pour réécrire l'opération :
$$ kP = k_1P + k_2\lambda P = k_1P + k_2\phi(P) $$
Cette transformation permet de remplacer une multiplication par un scalaire de $t$ bits par une somme de deux multiplications par des scalaires de $t/2$ bits. En utilisant l'algorithme d'entrelacement ("Shamir's trick"), le nombre total de doublements de points est réduit de moitié.

\subsection{Formulation par Réseaux (Lattices)}

Le problème de trouver $k_1, k_2$ petits peut être modélisé comme un problème de vecteur le plus court (SVP) dans un réseau de dimension 2. Définissons l'homomorphisme $f(u, v) = u + v\lambda \pmod n$. Le noyau de cet homomorphisme est un réseau $\mathcal{K}$ :
$$ \mathcal{K} = \{ (u,v) \in \mathbb{Z}^2 : u + v\lambda \equiv 0 \pmod n \} $$
Si nous trouvons un vecteur $v=(v_1, v_2) \in \mathcal{K}$ proche du vecteur $(k, 0)$, alors le vecteur différence $(k_1, k_2) = (k,0) - v$ sera court.

\subsection{Algorithme via Euclide Étendu}

Pour la dimension 2, l'algorithme d'Euclide étendu (EEA) est optimal pour trouver une base courte du réseau $\mathcal{K}$.

\paragraph{Phase 1 : Précalcul de la Base}
Nous appliquons l'algorithme d'Euclide étendu aux entiers $n$ et $\lambda$ pour produire une suite de restes $r_i$ et de coefficients $t_i$.
On s'arrête au premier index $m$ tel que $r_m \le \sqrt{n}$.
La base $\{v_1, v_2\}$ est définie par $v_1 = (r_m, -t_m)$ et $v_2 = (r_{m+1}, -t_{m+1})$.

\paragraph{Phase 2 : Décomposition de $k$}
On résout le système linéaire $(k,0) = \beta_1 v_1 + \beta_2 v_2$ dans $\mathbb{Q}$ (règle de Cramer), on arrondit les coefficients $b_i = \lfloor \beta_i \rceil$, et on calcule le vecteur résidu :
$$ (k_1, k_2) = (k,0) - b_1 v_1 - b_2 v_2 $$

% ===================================================================
\section{Analyse de Performance}

Analysons les coûts théoriques. Soit $L \approx \log_2 n$ la longueur en bits du scalaire $k$.

\begin{itemize}
    \item \textbf{Méthode Standard (Double-and-Add) :} Nécessite $L$ doublements (D) et en moyenne $0.5 L$ additions (A).
    \item \textbf{Méthode GLV :} Les scalaires $k_1, k_2$ ont une longueur d'environ $L/2$. La boucle principale s'exécute $L/2$ fois. Coût total : $0.5 L \cdot D + 0.375 L \cdot A$.
\end{itemize}

En supposant des coordonnées Jacobiennes où $1D \approx 0.7A$, le ratio de coût GLV/Standard est d'environ \textbf{0.60}, soit une réduction de 40\% du temps de calcul.

\begin{table}[h]
\centering
\caption{Comparaison des complexités pour un scalaire de 256 bits}
\vspace{0.3cm}
\begin{tabular}{lcccc}
\toprule
\textbf{Méthode} & \textbf{Doubl.} & \textbf{Add.} & \textbf{Précalc.} & \textbf{Complexité Rel.} \\
\midrule
Double-and-Add & 256 & 128 & 10 & 1.00 (Réf) \\
w-NAF ($w=5$) & 256 & $\sim 45$ & 8 & $\sim 0.85$ \\
\textbf{GLV} & \textbf{128} & \textbf{$\sim 96$} & \textbf{2} & \textbf{$\sim 0.60$} \\
GLV + w-NAF & 128 & $\sim 40$ & Petit & $\sim 0.55$ \\
\bottomrule
\end{tabular}
\end{table}

% ===================================================================
\section{Implémentation C avec GMP}

L'implémentation de la méthode GLV requiert une gestion hybride : arithmétique multiprécision pour la décomposition scalaire et arithmétique de corps fini modulaire pour les opérations sur la courbe. La bibliothèque GMP est idéale pour la première partie.

\subsection{Structures de Données}

\begin{lstlisting}
#include <gmp.h>

/* Contexte de la courbe contenant les constantes GLV */
typedef struct {
    mpz_t p;        // Module du corps premier
    mpz_t n;        // Ordre du sous-groupe
    mpz_t lambda;   // Valeur propre: lambda^2 + lambda + 1 = 0
    mpz_t beta;     // Racine de l'unite: beta^3 = 1

    // Vecteurs de base du reseau (precalcules)
    mpz_t v1;       // v1 (simplifie pour l'exemple)
    mpz_t v2;       // v2
    
    // Determinant de la matrice de base (pour Cramer)
    mpz_t det;
} GLV_Context;

/* Point en coordonnees Jacobiennes (X:Y:Z) */
typedef struct {
    mpz_t X; mpz_t Y; mpz_t Z;
} EC_Point;
\end{lstlisting}

\subsection{Algorithme de Précalcul (Initialisation)}
Cette fonction implémente l'Algorithme d'Euclide Étendu partiel.

\begin{lstlisting}
void glv_init_basis(GLV_Context *ctx) {
    mpz_t r0, r1, t0, t1, q, temp_r, temp_t, sqrt_n;
    mpz_inits(r0, r1, t0, t1, q, temp_r, temp_t, sqrt_n, NULL);

    // Initialisation EEA avec n et lambda
    mpz_set(r0, ctx->n);
    mpz_set(r1, ctx->lambda);
    mpz_set_ui(t0, 0);
    mpz_set_ui(t1, 1);

    // Condition d'arret : r < sqrt(n)
    mpz_sqrt(sqrt_n, ctx->n);
    
    // Boucle principale EEA
    while (mpz_cmp(r1, sqrt_n) > 0) {
        mpz_fdiv_q(q, r0, r1); // q = floor(r0 / r1)

        // r_new = r0 - q * r1
        mpz_mul(temp_r, q, r1);
        mpz_sub(temp_r, r0, temp_r);
        mpz_set(r0, r1);
        mpz_set(r1, temp_r);

        // t_new = t0 - q * t1
        mpz_mul(temp_t, q, t1);
        mpz_sub(temp_t, t0, temp_t);
        mpz_set(t0, t1);
        mpz_set(t1, temp_t);
    }

    // Extraction des vecteurs v1 et v2
    // v1 = (rm, tm) -> ici r1 et t1
    mpz_set(ctx->v1, r1); 
    mpz_neg(ctx->v1, t1); 
    
    // v2 provient de l'etape precedente (r0, -t0)
    mpz_set(ctx->v2, r0);
    mpz_neg(ctx->v2, t0);

    // Calcul du determinant D = v1*v2 - v2*v1
    mpz_mul(ctx->det, ctx->v1, ctx->v2); 
    // (Simplifie pour l'exemple, calcul vectoriel reel requis)
    
    mpz_clears(r0, r1, t0, t1, q, temp_r, temp_t, sqrt_n, NULL);
}
\end{lstlisting}

\subsection{Fonction de Décomposition (Exécution)}

\begin{lstlisting}
void glv_decompose(mpz_t k1, mpz_t k2, const mpz_t k, GLV_Context *ctx) {
    mpz_t b1, b2, tmp, half_det;
    mpz_inits(b1, b2, tmp, half_det, NULL);

    // Calcul de b1 = round(k * v2 / det)
    mpz_mul(tmp, k, ctx->v2); 
    
    // Astuce pour l'arrondi : ajouter det/2
    mpz_div_ui(half_det, ctx->det, 2);
    if (mpz_sgn(tmp) >= 0) mpz_add(tmp, tmp, half_det);
    else mpz_sub(tmp, tmp, half_det);
    mpz_div(b1, tmp, ctx->det);

    // Calcul de b2 similaire...

    // k1 = k - b1*v1 - b2*v2
    mpz_mul(k1, b1, ctx->v1); 
    mpz_mul(tmp, b2, ctx->v2); 
    mpz_add(k1, k1, tmp);
    mpz_sub(k1, k, k1);

    // k2 calcule similairement...

    mpz_clears(b1, b2, tmp, half_det, NULL);
}
\end{lstlisting}

% ===================================================================
\section{Extensions et Conclusion}

Bien que la méthode GLV originale soit limitée aux courbes ayant une multiplication complexe (ce qui est rare sur $\mathbb{F}_p$), ses principes ont été généralisés pour couvrir une classe beaucoup plus large de courbes.

\subsection{La Méthode GLS}
En 2009, Galbraith, Lin et Scott ont étendu l'idée GLV aux courbes définies sur des extensions quadratiques $\mathbb{F}_{p^2}$. L'astuce consiste à utiliser l'endomorphisme de Frobenius sur des tordues quadratiques. Cela permet de construire des courbes "GLV-ready" pour presque n'importe quel nombre premier $p$.

\subsection{GLV en Dimension 4}
En combinant un endomorphisme CM (GLV) avec l'endomorphisme de Frobenius (GLS), Longa et Sica ont proposé une décomposition en dimension 4. Les scalaires $k_i$ ont désormais une taille de $n^{1/4}$. Le nombre de doublements est divisé par 4 par rapport à la méthode standard.

\subsection{Conclusion}
La méthode GLV représente une avancée majeure dans l'histoire de la cryptographie sur courbes elliptiques. En transformant un problème purement arithmétique en un problème géométrique et algébrique, Gallant, Lambert et Vanstone ont ouvert la voie à des optimisations spectaculaires. L'adoption massive de la courbe secp256k1 par Bitcoin témoigne de la pertinence durable de cette approche.

\newpage
% ===================================================================
\section*{Bibliographie}

\begin{enumerate}
    \item On Multi-Scalar Multiplication Algorithms for Register-Constrained Environments - MDPI.
    \item Efficient and Secure Algorithms for GLV-Based Scalar Multiplication - Microsoft Research.
    \item Implementing 4-Dimensional GLV Method on GLS Elliptic Curves - Centre For Applied Cryptographic Research.
    \item Ranks of Elliptic Curves $y^2 = x^3 \pm 4px$ - m-hikari.com.
    \item Speed-up secp256k1 by using endomorphism, Paul Millr.
    \item Bitcoin key mechanism and elliptic curves over finite fields.
    \item Bitcoin Stack Exchange: Why g is 2 and 3 to derive values.
    \item A New Elliptic Scalar Multiplication Method using a Generalized EEA.
    \item Analysis on the elliptic scalar multiplication using integer sub-decomposition method.
    \item General 4-GLV Lattice Reduction Algorithms.
    \item Four-Dimensional Gallant-Lambert-Vanstone Scalar Multiplication - arXiv.
    \item Faster software for fast endomorphisms - COSADE.
    \item Refinement of the Four-Dimensional GLV Method on Elliptic Curves.
    \item Ready-made short basis for GLV+GLS on high degree twisted curves.
    \item Implementing 4-Dimensional GLV Method on GLS Elliptic Curves with j-Invariant 0.
    \item Four-Dimensional Gallant-Lambert-Vanstone Scalar Multiplication - Microsoft.
\end{enumerate}

\end{document}
